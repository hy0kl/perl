# perl 学习手记

# 第二章

## 双引号内字符串的反斜线转义

大体与 php 一致,以下有区别

组合 | 意义
---- | ---
\l | 将下字线转为小写
\L | 将它后面的所有字母转为小写,直到 \E 为止
\u | 将下个字母转为大写
\U | 将它后面的甩有字母转为大写,直到 \E 为止
\Q | 相当于把它到 \E 之间的非单词(no word)字符加上反斜线转义
\E | 结束 \L,\U和\Q开始的作用范围

## 标题变量

- 标题变量的名称以美元符号开头,此符号与称为魔符(sigil),然后是变量的 perl 标识符
- perl 不限于使用 ASCII 字符作为变量名.如果启用了 utf8 编译指令,那么可用于表示字母或数字的字符会多许多,拿它们作为变量名也是可以的.

## 字符串中的标题变量内插(variable interpolation)

## 操作符的优先级与结合性(从高到低排序)

`注: per 和 C 里面出现的操作符,优先级和结合性是相同的`

结合性 | 操作符
------ | -----
左 | 括号;给定参数的列表操作符
左 | ->
   | ++(自增) --(自减)
右 | **
右 | \ ! ! + -(单目操作符)
左 | =~ !~
左 | * / % x
左 | + - .(双目操作符)
左 | << >>
   | 具名的单目操作符(-X 文件测试; rand)
   | < <= > >= lt le gt ge("不相等"操作符)
   | == != <=> eq ne cmp("相等"操作符)
左 | &
左 | \| ^
左 | &&
左 | \|\|
   | .. ...
右 | ?:(三目操作符)
右 | = += -= .=(以及类似的赋值操作符)
左 | , =>
   | 列表操作符(向右结合)
右 | not
左 | and
左 | or xor

## 数值与字符串的比较操作符

比较 | 数字 | 字符串
---- | ---- | -----
相等 | == | eq
不等 | != | ne
小于 | <  | lt
大于 | >  | gt
小于或等于 | <= | le
大于或等于 | >= | ge

## 布尔值

- 如果数字,0为假;所有其他数字都为真.
- 如果是字符串,空字符串(''), '0' 为假;所有其他字符串都为真.
- 如果既不是数字也不是字符串,那就先转换成数字或字符串再行判断.

## 获取用户输入

```
使用"行输入"操作符 <STDIN>
```

### chomp 操作符,去掉字符串末尾的换行符

## undef 值

在首次赋值前,变量的初始值是特殊的 undef(末定义)值.当数字使用,它会表现得像零;如果当成字符串使用,它就会表现得像空字符串.

undef 既不是数字也不是字符串,它完全是另一种类型的标题值.

## defined函数

要判断某个字符串是 undef 而不是空字符串,可以使用 defined 函数.如果是 undef,该函数返回假,否则返回真.

# 第三章 列表与数组

- 列表(list)指的是标量的有序集合
- 数组(array)是存储列表的变量
- 访问数组中的元素,使用下标数字(subscript)来引用.
- 对索引值超过数组尾端的元素进行赋值,数组将会根据需要自动扩大.如果在扩展过程中需要创建增补元素,它们的默认取值为 undef.
- 最后一个元素的索引值, $#array_name.
- 列表直接量(list literal,在程序代码中表示一列数据的写法),可以由圆括号内用逗号隔开的一串数据表示,这些数据就称为列表元素.
- .. 范围操作符,只能向上计数
- qw 简写  
  qw 表示"quoted word(加上引号的单词)"或"quoted by whitespace(用空白圈引)"
- 列表赋值  
  ($fred, $barney) = ($barney, $fred)   # 交换两个变量的值
- 希望引用整个数组时, perl 提供了一个比较简单的记法.在数组名之前加上@(at)字符(后面没有检索用的方括号).将它读作"all of the(全部的,所有的)"
- pop 和 push 操作符
- shift 和 unshift 操作符
- splice 操作符  
  最多可接受4个参数,最后两个参数可选.第一个参数是要操作的目标数组;第二个参数是要操作的一组元素的开始位置;第三个参数指定要操作的元素长度;第四个参数是要替换的列表.
- perl 默认变量: $_
- reverse 操作符  
  读取列表的值(也可能来自数组),并按相反的次序返回该列表.
- sort 操作符
- each 操作符

## 标量的上下文与列表的上下文

同一个表达式出现在不同的地方有不同的意义.

上下文感知(context sensitivity)

### 标量上下文中使用产生列表的表达式

### 在列表上下文中使用产生标量的表达式

### 强制指定标量上下文

### 列表上下文中的 \<STDIN\>

# 子程序

## 定义子程序

```
sub func_name {
    # 子程序实现体
}
```

- 子程序可以被定义在程序中的任意位置
- 子程序的定义是全局的
- 同名子程序后面的会覆盖掉前面;如果启用了警告信息,会提示子程序被重复定义
- 子程序中可以使用任何全局变量

## 调用子程序

```
&func_name();
```

## 返回值

- 所有的子程序都有一个返回值.子程序没有"有返回值"或"没有返回值"之分.
- 在子程序的执行过程中,最后一次运算的结果(不管是什么)都会被自动当成子程序的返回值.

## 参数

- 要传递参数列表到子程序里,只要在子程序调用的后面加上括号圈引的列表表达式就可能了,参数列表将会被传入子程序,让子程序随意使用.
- per 会自动将参数列表化名为特殊的数组变量 @_,该变量在子程序执行期间有效.
- @_ 变量是子程序的私有变量.

## 子程序中的私用变量

- 借助 my 操作符来创建私有变量,称之为词法变量(lexical variable)

## 变长参数列表

```perl
sub max {
    my($max_so_far) = shift @_; # 数组中的第一值,暂时把它当成最大值
    foreach (@_) {              # 遍历数组
        if ($_ > $max_so_far) {
            $max_so_far = $_;
        }
    }

    $max_so_far;
}
```

## 关于词法(my)变量

- 可以使用在任何语句块内,包括但不仅限于子程序语句块, if, while, foreach 语句块.
- 词法变量的作用域(scope)受限于定义它的最内层语句块(或文件).
- my 操作符不会更改变量赋值时的上下文.

## use strict 编译指令

## return 操作符

## 省略与号

- 如果编译器在调用子程序前看到过子程序的定义,或者 perl 通过词法规则判断它只能是个子程序调用,那么对待子程序可以像内置函数那样,在调用时省略与号.
- 只要将参数列表放进括号里,它就一定是函数调用.

## 非标量返回值

## 持久性私有变量

- 使用 state 操作符来声明的变量,可以在子程序的多次调用期间保留变量之前的值,并将变量的作用域局限于子程序内部.
- 在使用数组和哈希类型的 state 变量时,有一些轻微限制.  
  perl5.10 中不能在列表上下文初始化数组和哈希类型的 state 变量:  
  state @array = qw(a b c); # 错误!

# 第五章 输入与输出

## 读取标准输入

```
<STDIN>

chomp($line = <STDIN>);

while (defined($line = <STDIN>)) {
    print "I saw $line";
}

while (<STDIN>) {
    print "I saw $_";
}
```

## 来自钻石操作符的输入

```
while (<>) {
    chomp;
    print "It was $_ that I saw!\n";
}
```

## 调用参数

- @ARGV 数组是由 perl 解释器事先建立的特殊数组,其内容是由命令行参数组成的列表.

## 输出到标准输出

- print 后面的括号可有可无.

```
print <>;       # 相当于 unix 下的 cat 命令
print sort <>;  # 相当于 unix 下的 sort 命令
```

## 用 printf 格式化输出

## 数组和 printf

```
printf "The items are:\n" . ("%10s\n" x @items), @items;
```

## 文件句柄(filehandle)

- 6个特殊的文件句柄是 perl 保留的,分别是: STDIN, STDOUT, STDERR, DATA, ARGV以及 ARGVOUT.

## 打开文件句柄

```
open R_FP, '<', $file_name;
open W_FP, '>', $file_name;
open LOG, '>>:encoding(UTF-8)', &logfiel_name();
```

## 以二进制方式读写文件句柄

## 有问题的文件句柄.

## 关闭文件句柄

```
close LOG;
```

## 用 die 处理致命的错误

```
if (! open LOG, '>>', 'logfile') {
    die "Can't create logfile: $!";
}
```

## 用 warn 送出警告信息

## 自动检测致命错误

```
use autodie;
```

## 使用文件句柄

```
if (! open PASSWD, "/etc/passwd") {
    die "How did you get logged in? ($!)";
}

while (<PASSWD>) {
    chomp;
    # ...
}
```

## 改变默认的文件输出句柄

```
select LOG_FILE
```

```
select LOG;
$| = 1; # 不要将 LOG 的内容保留在缓冲区
select STDOUT;
# ...
print LOG "This gets written to the LOG at once!\n";
```

## 重新打开标准文件句柄

```
# 将错误信息写到错误日志中
if (! open STDERR, '>>', '/home/work/error.log') {
    die "Can't open error log for append: $!";
}
```

在重新打三个系统文件句柄STDIN, STDOUT, STDERR 失败时, perl 会找回原先的文件句柄.

## 用 say 来输出(自动加换行)

## 标量变量中的文件句柄

# 第六章 哈希

## 访问哈希元素

```
$hash{$some_key};
```

## 访问整个哈希

```
%some_hash = ('foo', 35, 'bar', 12.4, 2.5, 'hello',
    'wilam', 1.72e30, 'betty', "bye\n");
```

## 胖箭头

```
my %last_name = (
    'fred' => 'flintstone',
    'dino' => undef,
    'betty'=> 'rubble',
);
```

## 哈希函数

### keys 和 values 函数

```
my %hash = ('a' => 1, 'b' => 2, 'c' => 3,);
my @k = keys %hash;
my @v = values %hash;
```

- 只要在取得键与值这两个动作之间不修改哈希,顺序是一致.
- 在标量上下文中,这两个函数返回哈希元素(键-值对)的个数.

```
my $count = keys %hash;
```

### each 函数

```
while (($key, $value) = echo %hash) {
    print "$key => $value\n";
}
```

- each 返回的键一值对与 keys和values 函数返回的顺序一致

```
foreach $key (sort keys %hash) {
    $value = $hash{$key};
    # ...
}
```

### exists 函数

### delete 函数

### %ENV 哈希

# 第七章 漫游正则表达式王国

- 元字符点号(.)能匹配任意一个字符,换行符("\n")除外.
- 简单的量词,星号(*)来匹配前面的条目零次或多次.
- 常戏称 .* 为"捡破烂(any old junk)"模式,因为它能匹配字符串中的随便什么东西.
- 加号(+)匹配前一个条目一次以上.
- 问号(?)表示前一个条目可有可无.

## 模式分组

正则表达式中,圆括号((),或称小括号)的作用是对字符串分组.

## 择一匹配

竖线(|)通常可以读成"或",意思是要么匹配左边内容,要么匹配右边的内容.

## 字符集

```
字符集(character classs),指的是一组可能出现的字符,通过写在方括号([])内表示.它只匹配单个字符,但可以是字符集列出的任何一个.

可以在字符集开头的地方加上脱字符(caret,^)来表示这些字符除外.
```

### 字符集的简写

```
\d 表示任意一个数字的字符集
\s 匹配任意空白符,效果大抵等同于 Unicode属性\p{Space}
\R perl5.10中引入,匹配任意一种断行符
\w 一直被称作"单词(word)"字符,但它匹配的字符并不是严格意义上的单词字符
```

### 反义简写

大写版本表示否定意义.


# 第8章 用正则表达式进行匹配

## 用 m// 进行匹配

应该明智地选择模式中不会出现的字符作为定界符,提高代码可读性,降低维护成本.

## 模式匹配修饰符

- 用 /i 进行大小写无关的匹配
- 用 /s 匹配任意字符
- 用 /x 加入空白符

## 组合选项修饰符

## 锚位

```
\A 锚位匹配字符串的绝对开头.如果开头位置上不匹配,是不会顺移到下一个位置继续尝试.
m{\Ahttps?://}i

\z 要切尔西字符串的绝对末尾.
m{\.png\z}i

匹配一个空行
/\A\s*\Z/

单词锚位
\b 是单词边界锚位
```

## 绑定操作符 =~

## 捕获变量

### 捕获变量的存续期

捕获变量通常能存活到下次成功匹配为止.失败的匹配不会改动上次成功匹配时捕获的内容,而成功的匹配会将它们的值重置.

### 不捕获模式

在左括号后面加问号和冒号(?:),告诉 perl 这对不括号完全是为了分组而存在.

### 命名捕获

(?<LABEEL>PATTERN) 提取捕获内容时需要访问的变量变成了 $+{LABEEL};

### 自动捕获变量

```
$& 保存了整个的匹配区段
匹配区段之前的内容存到 $` 里
匹配区段之后的内容刚存到 $' 里

perl5.10 或以上的版本,修饰符 /p 只会针对特定的正则表达式开启类似自动捕获变量,但它的名字不再是 $`, $&和$',而是用 ${^PREMATCH}, ${^MATCH}和${^POSTMATCH}.
```
















